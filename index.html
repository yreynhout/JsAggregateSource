<html>
<head>
<script src="scripts/jquery-1.10.2.min.js"></script>
<script src="scripts/uuid.js"></script>
<script src="scripts/json2.min.js"></script>
<script src="scripts/store.min.js"></script>
<script src="scripts/aggregatesource.js"></script>
<script src="scripts/model.js"></script>
<script>
if (!store.enabled) {
	console.error("Local storage is not supported by your browsa - No demo for you.");
} else {
	//store.set('item/1', []);
	var streamId = uuid.v4();

	//First command
	var original = new Model.InventoryItem(streamId, 'Boxer shorts');
	for(var index=0;index<1000;index++){
		original.checkIn(Math.floor((Math.random()*10)+1));	
	}
	var originalChanges = original.getChanges();
	for(var index = 0, length = originalChanges.length; index < length; index++) {
		console.info(JSON.stringify(originalChanges[index]));
	}
	appendToStream(streamId, originalChanges).
	done(function() {
		readFromStream(streamId).
		done(function(loadedChanges) {
			var loaded = new Model.PrivateInventoryItemConstructor();
			loaded.initialize(loadedChanges);
			loaded.checkIn(2);
			var newChanges = loaded.getChanges();
			for(var index = 0, length = newChanges.length; index < length; index++) {
				console.info(JSON.stringify(newChanges[index]));
			}
			appendToStream(streamId, newChanges).done(function() { console.info("Done with last ES write."); });
		})
	});
	//store.set('item/1', originalChanges);

	
	/*//Second command
	var loadedChanges = store.get('item/1');
	var loaded = new Model.PrivateInventoryItemConstructor();
	loaded.initialize(loadedChanges);
	loaded.checkIn(2);
	var newChanges = loaded.getChanges();
	for(var index = 0, length = newChanges.length; index < length; index++) {
		console.info(JSON.stringify(newChanges[index]));
	}
	store.set('item/1', originalChanges.concat(newChanges));

	//Third command
	var reloadedChanges = store.get('item/1');
	var reloaded = new Model.PrivateInventoryItemConstructor();
	reloaded.initialize(reloadedChanges);
	reloaded.deactivate();
	var newestChanges = reloaded.getChanges();
	for(var index = 0, length = newestChanges.length; index < length; index++) {
		console.info(JSON.stringify(newestChanges[index]));
	}
	store.set('item/1', reloadedChanges.concat(newestChanges));	*/
}

function prepareChangesForES(changes) {
	var payload = [];
	for(var index=0,length=changes.length;index<length;index++){
		var change = changes[index];
		payload.push({
			"eventid": uuid.v4(),
			"eventType": change.name,
			"data": change.data
		});
	}
	return payload;
}

function appendToStream(streamId, changes) {
	return $.ajax({
        type: 'POST',
        url: 'http://127.0.0.1:2113/streams/' + streamId,
        data: JSON.stringify(prepareChangesForES(changes), null, 2),
        contentType: 'application/json'
      });
}

function readFromStream(streamId) {
	var deferred = new $.Deferred();
	var streamDataGetter = function (events, streamData) {
			var tasks = [];
			for(var index=0,length=streamData.entries.length;index<length;index++) {
		      	tasks.push(
		      		$.ajax({
						type:'GET',
						url: streamData.entries[index].id
					}).done(function(eventData) {
						events.push({ 
							"version": eventData.content.eventNumber, 
							"name": eventData.content.eventType,
							"data": eventData.content.data 
						});
					})
				);
		    }
		    $.when.apply($, tasks).then(function() {
		    	var nextLinks = streamData.links.filter(function(item) { return item.relation === "next"; });
		    	if (nextLinks.length === 1) {
		    		$.ajax({
						type:'GET',
						url: nextLinks[0].uri
					}).done(function(nextStreamData) {
						streamDataGetter(events, nextStreamData);
					});
		    	} else {
		    		deferred.resolve(events.sort(function(item1, item2) {
		    			if(item1.version < item2.version) 
		    				return -1;
		    			if(item1.version > item2.version)
		    				return 1;
		    			return 0;
		    		}));
		    	}
		    });
	};
	var events = [];
	$.ajax({
		type:'GET',
		url: 'http://127.0.0.1:2113/streams/' + streamId
	}).done(function(streamData) {
		streamDataGetter(events, streamData);
	}).fail(function(error){
		console.log("ES read failure");
	});
	return deferred;
	/*$.ajax({
		type:'GET',
		url: 'http://127.0.0.1:2113/streams/' + streamId
	}).done(function(data) {
		console.info('ES read success');
		var tasks = [];
		for(var index=0,length=data.entries.length;index<length;index++) {
	      	tasks.push(
	      		$.ajax({
					type:'GET',
					url: data.entries[index].id
				}).done(function(data) {
					instance.initialize([ { "name": data.summary, "data": data.content.data }]);
				})
			);
	    }
	    $.when.apply($, tasks).then(function() { callback(); });
	}).fail(function(){
		console.info('ES read failure');
	});*/
}


//Get stream
//When that's done, get each event and push it onto a stack
//When all events in this batch are done, repeat until no more batches
</script>
</head>
<body></body>
</html>